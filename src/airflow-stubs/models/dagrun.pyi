from airflow.exceptions import AirflowException as AirflowException
from airflow.models.base import Base as Base, ID_LEN as ID_LEN
from airflow.settings import Stats as Stats, task_instance_mutation_hook as task_instance_mutation_hook
from airflow.ti_deps.dep_context import DepContext as DepContext
from airflow.utils import timezone as timezone
from airflow.utils.db import provide_session as provide_session
from airflow.utils.log.logging_mixin import LoggingMixin as LoggingMixin
from airflow.utils.sqlalchemy import UtcDateTime as UtcDateTime
from airflow.utils.state import State as State
from sqlalchemy.orm.session import Session
from typing import Any, Optional

class DagRun(Base, LoggingMixin):
    __tablename__: str
    ID_PREFIX: str
    ID_FORMAT_PREFIX: Any
    id: Any
    dag_id: Any
    execution_date: dt.datetime
    start_date: Any
    end_date: Any
    run_id: Any
    external_trigger: Any
    conf: Any
    dag: Any
    __table_args__: Any
    def get_state(self): ...
    def set_state(self, state) -> None: ...
    def state(self): ...
    @classmethod
    def id_for_date(cls, date, prefix=...): ...
    def refresh_from_db(self, session: Any | None = ...) -> None: ...
    @staticmethod
    def find(dag_id: Any | None = ..., run_id: Any | None = ..., execution_date: Any | None = ..., state: Any | None = ..., external_trigger: Any | None = ..., no_backfills: bool = ..., session: Any | None = ...): ...
    def get_task_instances(self, state: Any | None = ..., session: Any | None = ...): ...
    def get_task_instance(self, task_id, session: Any | None = ...): ...
    def get_dag(self): ...
    def get_previous_dagrun(self, state: Optional[str] = ..., session: Optional[Session] = ...) -> Optional[DagRun]: ...
    def get_previous_scheduled_dagrun(self, session: Any | None = ...): ...
    def update_state(self, session: Any | None = ...): ...
    def verify_integrity(self, session: Any | None = ...) -> None: ...
    @staticmethod
    def get_run(session, dag_id, execution_date): ...
    @property
    def is_backfill(self): ...
    @classmethod
    def get_latest_runs(cls, session): ...
